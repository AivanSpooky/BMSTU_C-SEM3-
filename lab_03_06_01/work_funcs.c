#include "work_funcs.h"

void make_spiral(int a[][M], size_t a_n)
{
    // Задаем вспомогательные переменные
    // n_0 - строка, на которой мы находимся в данный момент
    // n_1 - строка, до которой надо дойти от n_0 (конечная)
    // m_0 - столбец, на котором мы находимся в данный момент
    // m_1 - столбец, до которого надо дойти от m_0 (конечный)
    // reduct - переменная, которая уменьшает диапазон значений n_0, n_1, m_0, m_1 после каждого прохода круга по часовой стрелке
    size_t n_0 = 0, n_1 = (a_n - 1), m_0 = 0, m_1 = (a_n - 1);
    size_t reduct = 0;
    for (size_t i = 1; i <= a_n * a_n; i++)
    {
        /*
        Матрица заполняется с элемента (0;0) по спирали по часовой стрелке.
        В ходе полного заполнения матрица заполняет несколько кругов по часовой стрелке
        (за переход на следующий круг отвечает переменная reduct).
        Это значит, что сначала мы заполняем клетки круга, двигаясь вправо по матрице (1ый этап),
        потом вниз (2ой этап), затем влево (3ий этап) и в конце вверх (4ый этап).
        Необходимость двигаться в том или ином направлении определяет номер этапа.
        Номер этапа определяется условием в if.
        Также необходимость объясняется тем, что когда мы двигаемся вправо, значит справа есть незаполненные клетки (аналогично и с другими направлениями).
        */ 
        a[n_0][m_0] = i;
        // Если необходимо двигаться по строкам вниз, а по столбцам вправо
        // Двигаемся на 1 ячейку вправо 
        if (n_0 <= n_1 && m_0 < m_1)
        {
            m_0++;
        }
        // Если необходимо двигаться по строкам вниз, а по столбцам влево
        // Двигаемся на 1 ячейку вниз 
        else if (n_0 < n_1 && m_0 >= m_1)
        {
            n_0++;
        }
        // Если необходимо двигаться по строкам вверх, а по столбцам влево
        // Двигаемся на 1 ячейку влево 
        else if (n_0 >= n_1 && m_0 > m_1)
        {
            m_0--;
        }
        // Если необходимо двигаться по строкам вверх, а по столбцам вправо
        // Двигаемся на 1 ячейку вверх 
        else if (n_0 > n_1 && m_0 <= m_1)
        {
            n_0--;
        }
        // Если шагами текущий столбик дошел до конечного, то меняем конечный столбик так, чтобы изменилось направление движения
        // То есть, если изначально направление движения было влево, то после замены m_1 оно станет вправо.
        if (m_0 == m_1)
        {
            m_1 = (m_0 == (a_n - 1 - reduct)) ? reduct : a_n - 1 - reduct;
        }
        // Если шагами текущая строка дошла до конечной, то меняем конечную строку так, чтобы изменилось направление движения
        // То есть, если изначально направление движения было вниз, то после замены n_1 оно станет вверх.
        if (n_0 == n_1)
        {
            n_1 = (n_0 == (a_n - 1 - reduct)) ? reduct : a_n - 1 - reduct;
        }
        // Если прошли полный круг по часовой стрелке, то переходим на более мелкий круг
        // Соответсвенно reduct увеличиваем на 1
        if (n_0 - 1 == n_1)
        {
            reduct++;
            n_1 = a_n - 1 - reduct;
            m_1 = a_n - 1 - reduct;
        }
    }
}
