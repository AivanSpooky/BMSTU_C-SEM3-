#include <stdio.h>
#include <stdlib.h>
#define OK 0
#define ERR 1

// Функции динамического выделения памяти
#if OK == ERR
void *malloc(unsigned s);
void *calloc(unsigned n, unsigned size);
void *realloc(void *bl, unsigned ns);
void free(void *ptr)
Для выделения памяти необходимо вызвать одну из трёх функций (C99 7.20.3), объявленных в заголовочном файле stdlib.h:
• malloc (выделяет блок памяти и не инициализирует его);
• calloc (выделяет блок памяти и заполнят его нулями);
• realloc (перевыделяет предварительно выделенный блок памяти).
Указанные функции не создают переменную, они лишь выделяют область памяти.
В качестве результата функции возвращают адрес расположения этой области в памяти компьютера, т. е. указатель.
Поскольку ни одна из этих функций не знает данные какого типа будут располагаться в выделенном блоке все они возвращают указатель на void.
В случае если запрашиваемый блок памяти выделить не удалось, любая из этих функций вернёт значение NULL.
После использования блока памяти он должен быть освобождён. Сделать это можно с помощью функции free.
• Функция realloc. Особенности использования.
Если указатель нулевой, а размер – нет, то функция выделяет память аналогично malloc. realloc(NULL, 1);
Если указатель ненулевой, а размер – нулевой, то функция освобождает память аналогично free. realloc(ptr, 0);
Если же и указатель, и размер ненулевые, то память по указателю перевыделяется: realloc(ptr, 1);
выделится новая область памяти, данные из старой области скопируются в новую, старая область освободится.
• Общие «свойства» функций malloc, calloc, realloc.
Функция malloc (C99 7.20.3.3) выделяет блок памяти указанного размера size. Величина size указывается в байтах.
Выделенный блок памяти не инициализируется (т. е. содержит «мусор»). Для вычисления размера требуемой области памяти необходимо использовать операцию sizeof.
Функция calloc (C99 7.20.3.1) выделяет блок памяти для массива из n элементов, каждый из которых имеет размер size байт.
Выделенная область памяти инициализируется таким образом, чтобы каждый бит имел значение 0.

Функция выделения памяти и явное приведение типа: за и против.
Преимущество явного приведения: 
• компиляция c++ компилятором
• Совместимомть с malloc до стандарта ANSI C (был прототип char *malloc(size_t size))
• дополнительная «проверка» аргументов разработчиком.
Недостатки: 
• Загромождение кода - начиная с ANSI C приведение не нужно 
• может скрыть ошибку, если забыли подключить stdlib.h
• в случае изменения типа указателя придётся менять и тип в приведении.

Особенности выделения 0 байтов памяти.
Результат вызова функций malloc, calloc или realloc, когда запрашиваемый размер блока равен 0, зависит от реализации (implementation-defined C99 7.20.3):
• вернётся нулевой указатель;
• вернётся «нормальный» указатель, но его нельзя использоваться для разыменования.
Поэтому перед вызовом этих функций нужно убедиться, что запрашиваемый размер блока не равен нулю.
Передача отрицательного значения в malloc - неопределенное поведение
#endif

int main(void)
{
    // Пример на проверку успешности выделения памяти при malloc, realloc
    {
        int *ptr = malloc(5 * sizeof(int)); // Выделение памяти на 5 целых чисел

        if (ptr == NULL)
        {
            printf("Ошибка выделения памяти\n");
            return ERR;
        }

        // Использование realloc для увеличения размера выделенной памяти
        int *newPtr = realloc(ptr, 10 * sizeof(int));

        if (newPtr == NULL) {
            printf("Ошибка выделения памяти\n");
            free(ptr); // Освобождение исходной памяти
            return ERR;
        } else {
            ptr = newPtr; // Присвоение нового указателя переменной-указателю
        }
        // Использование ptr...

        free(ptr); // Освобождение памяти
    }
    
    return OK;
}