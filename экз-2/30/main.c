#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//#include <malloc.h>
#include <alloca.h>

#define OK 0
#define ERR 1


#if OK == ERR
• Можно ли реализовать в языке Си функцию со следующим прототипом int f(. . . )? Почему?
int f(...); - НЕТ
- Так как внутри функции невозможно получить указатель на стек, где хранятся аргументы
- Во время компиляции компилятору не известны ни количество параметров, ни их типы.
- Во время компиляции компилятор не выполняет никаких проверок.
НО список параметров функции с переменным числом аргументов совсем пустым быть не может.
int f(int k, ...);

(та самая кринж реализация с меняющимся указателем на последний явный параметр)
Почему для реализации функций с переменным числом параметров нужно использовать возможности стандартной библиотеки? 
Чтобы не учитывать
• особенности реализации стека в разных компиляторах
• Выравнивание
• расширение типов данных до четырёх байт при попадании в стек

Какой заголовочный файл стандартной библиотеки нужно использовать? Какие типы и макросы из этого файла вам понадобятся? Для чего?
stdarg.h
• va_list
• void va_start(va_list argptr, last_param)
• type va_arg(va_list argptr, type)
• void va_end(va_list argptr)
Макрос va_start устанавливает указатель типа va_list на явный параметр,
макрос va_arg перемещает указатель на следующий параметр,
а макрос va_end обнуляет указатель.
в теле функции с переменным числом параметров до первого использования указанных макросов должно появиться объявление объекта типа va_list,
например va_list LastP; фактически это является объявлением указателя;
указанный объект связывается с последним явным параметром (перед многоточием) переменного списка параметров с помощью макроса va_start,
например va_start(LastP,P); таким образом происходит инициализация указателя;
передвижение по переменному списку параметров выполняется макросом va_arg.
Для этого, как указано выше, тоже необходимо явно указывать тип очередного параметра, то есть программист должен его знать в момент написания программы.
Если все параметры в списке целого типа, то вызов va_arg выглядит так: va_arg(LastP,int); 
после всей обработки ставится вызов va_end, например va_end(LastP)

Какая особенность языка Си упрощает реализацию функций (с точки зрения компилятора) с переменным числом параметров?
• все параметры при вызове помещаются в стек. Если мы каким-то образом установим указатель на начало списка параметров в стеке,
то, манипулируя с указателем, мы, в принципе, можем «достать» все параметры
Почему при вызове va_arg(argp, short int) выдается предупреждение?
• Так как в соглашении о вызове cdecl сказано, что аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт.
А short int меньше 4-х байт. Какая "опасность" существует при использовании функций с переменным числом параметров?
• передача аргумента не того типа, который задумывался, или не тем способом, который подразумевался при разработке
• Разные соглашения о вызове
• Передача неправильного количества переменных

• Как написать функцию, которая получает строку форматирования и переменное число параметров (как функция printf), и передает эти данные функции printf?
(Подсказка: см. последний вариант реализации журналирования.)
#include <stdio.h>
#include <stdarg.h>

int log (const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    vprintf(format,  ap);
    va_end(ap);
}
#endif

#ifdef OK // Функции

#endif




int main(void)
{
    int *nums = alloca(3 * sizeof(int));
    return OK;
}