#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//#include <malloc.h>
#include <alloca.h>

#define OK 0
#define ERR 1


#if OK == ERR
Массив переменной длины представляет собой структуру данных массива, длина которой определяется во время выполнения.
В C говорят, что VLA имеет изменяемый тип, который зависит от значения.
Чем отличается статический массив от variable length array?
• Длина такого массива вычисляется во время выполнения программы, а не во время компиляции.
• Массивы переменного размера нельзя инициализировать при определении.
• Массивы переменной длины облегчают описание заголовков функций, которые обрабатывают массивы.
void process_array(size_t size, int arr[size]);
Здесь мы передаем размер массива как параметр функции, и массив объявляется с использованием VLA.
Это позволяет функции обрабатывать массивы переменной длины без необходимости заранее знать их размер.

Какую операцию языка Си пришлось реализовывать по-другому (не как для встроенных типов) специально для variable length array?
Оператор sizeof - возвращает кол-во элементов статического массива, поэтому для vla массивов он отрабатывает во время выполнения,
а не во время компиляции как в остальных случаях.

Особенности использования VLA.
• Массивы переменного размера нельзя инициализировать при определении. Выделение памяти для VLA выполняется медленнее,
чем для массива константного размера, возможны ошибки с переполнением стека во время исполнения.
Справедлива ли для variable length array адресная арифметика?
• Да, справедлива
Как вы думаете почему variable length array нельзя инициализировать?
• Если выделяется под него память не вручную, то выделится не больше, чем надо на саму структуру - и элементы массива записывать будет просто некуда.
А так они просто записываются за последним полем структуры.
Инициализация выполняется во время компиляции, а vla создается во время работы программы. Следовательно, из-за особенности работы стека
(заполнения стека от конца к началу) во время компиляции не будет известен адрес, с которого начинается массив
Также возникают проблемы выхода за границы выделенной памяти, так как размер массива становится известным только во время выполнения.

Для чего используется VLA? Приведите примеры.
• Для выделение временного буфера, малого размера и динамического размера. Пример: универсальный обмен: void swap(void *, void*, size_t)
В какой области и «кем» выделяется память под массив переменной длины?
• Память под элементы массива выделяется на стеке во время выполнения кода. Выделение памяти происходит с помощью команды объявления массива программистом.

Функция alloca.
#include <alloca.h>
void *alloca(size_t size);  
Функция alloca выделяет область памяти, размером size байт, на стеке. Функция возвращает указатель на начало выделенной области.
Эта область автоматически освобождается, когда функция, которая вызвала alloca, возвращает управления вызывающей стороне. Если выделение вызывает переполнение стека, поведение программы не определено.
• alloca vs VLA.
Это в общем про динамическое выделение на стеке
“+”
• Выделение происходит быстро.
• Выделенная область освобождается автоматически.
“–”
• Функция нестандартная.
• Серьезные ограничения по размеру области.
• Неопределенное поведение при переполнении стека
                                VLA                              alloca
Входит в стандарт                +                                 -
Можно зациклить?                 -                                 +
Очищается           При выходе из блока             При выходе из вызвавшей функции
Можно использовать до C99        -                                 +
#endif

#ifdef OK // Функции

#endif




int main(void)
{
    int *nums = alloca(3 * sizeof(int));
    return OK;
}