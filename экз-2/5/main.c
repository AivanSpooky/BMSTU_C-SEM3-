#include <stdio.h>
#include <stdlib.h>
#define OK 0
#define ERR 1

// Функции динамического выделения памяти
#if OK == ERR
Утилита make: назначение, входные данные, идея алгоритма работы.
make — утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Необходимо создать так называемый сценарий сборки проекта (make-файл).
Этот файл описывает
• отношения между файлами программы;
• содержит команды для обновления каждого файла.
Утилита make использует информацию из make-файла и время последнего изменения каждого файла для того, чтобы решить, какие файлы нужно обновить.

Разновидности утилиты make.
• GNU Make (рассматривается на курсе)
• BSD Make
• Microsoft Make (nmake)

• Сценарий сборки проекта: название файла, структура сценария сборки
цель: зависимость_1 ... зависимость_n
[tab]команда_1
[tab]команда_2
...
[tab]команда_m

что создать/сделать: из чего создать
как создать/что сделать

Утилита make руководствуется правилами, описанными в файле Makefile. Эти правила состоят из следующих составных частей:
Цели (Targets): Цель представляет собой файл или действие, которое нужно выполнить.
Это может быть исполняемый файл, объектный файл, архив, или просто действие, которое нужно выполнить (например, "clean" для очистки временных файлов).
Цель указывается в начале строки, за которой следует двоеточие.
Зависимости (Dependencies): Зависимости представляют собой файлы или другие цели, от которых зависит текущая цель.
Если какой-либо из файлов зависимости изменяется, то цель должна быть пересобрана. Зависимости указываются после цели, разделенные пробелом.
Команды сборки (Build Commands): Это команды, которые нужно выполнить для сборки цели.
Они идут после строки с целью и зависимостями, начинаются с табуляции и выполняются в командной оболочке.
Утилита make использует эти правила для определения порядка сборки файлов и оптимизации процесса компиляции.
Она анализирует время модификации файлов и их зависимости, и, используя Makefile, определяет, какие файлы нужно пересобрать.
Затем она выполняет соответствующие команды сборки, оптимизируя процесс и ускоряя компиляцию.

Особенности выполнения команд
• Ненулевой код возврата может прервать выполнение сценария.
• Каждая команда выполняется в своём shell.

Простой сценарий сборки.
greeting.exe: hello.o bye.o main.o
    gcc -o greeting.exe hello.o bye.o main.o
test_greeting.exe: hello.o bye.o test.o
    gcc -o test_greeting.exe hello.o bye.o test.o
hello.o: hello.c hello.h
    gcc -std=c99 -Wall -Werror -pedantic -c hello.c
bye.o: bye.c bye.h
    gcc -std=c99 -Wall -Werror -pedantic -c bye.c
main.o: main.c hello.h bye.h
    gcc -std=c99 -Wall -Werror -pedantic -c main.c
test.o: test.c hello.h bye.h
    gcc -std=c99 -Wall -Werror -pedantic -c test.c
.PHONY clean:
    rm *.o *.exe

Алгоритм работы утилиты make на примере простого сценария сборки.
Первый запуск make:
make читает сценарий сборки и начинает выполнять первое правило:
greeting.exe: hello.o bye.o main.o
    gcc -o greeting.exe hello.o bye.o main.o
Для выполнения этого правила необходимо сначала обработать зависимости hello.o bye.o main.o
make ищет правило для создания файла hello.o:
hello.o: hello.c hello.h
    gcc -std=c99 -Wall -Werror -pedantic -c hello.c
Файл hello.o отсутствует, файлы hello.c и hello.h существуют. Следовательно, правило для создания hello.o может быть выполнено 
gcc -std=c99 -Wall -Werror -pedantic -c hello.c
Аналогично обрабатываются зависимости bye.o и main.o.
Все зависимости получены, теперь правило для построения greeting.exe может быть выполнено
gcc -o greeting.exe hello.o bye.o main.o

Ключи запуска утилиты make.
• Ключ «-f» используется для указания имени файла сценария сборки
make -f makefile_2
• Ключ «-B» используется для безусловного выполнения правил
make -B
• Ключ «-n» используется для вывода команд без их выполнения
make –n
• Ключ «-i» используется для игнорирования ошибок при выполнении команд
make -i
#endif

#ifdef OK // Функции

#endif


int main(void)
{
    return OK;
}