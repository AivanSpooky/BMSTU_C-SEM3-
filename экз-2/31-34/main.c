#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//#include <malloc.h>
#include <alloca.h>

#define OK 0
#define ERR 1


#if OK == ERR
!! Что делает препроцессор? В какой момент в процессе получения исполняемого файла вызывается препроцессор?
Препроцессор представляет собой макроязык, который используется для преобразования программы до того, как она будет скомпилирована
• Удаление комментариев 
• Включение файлов 
• Текстовые замены ( #define ) 
• Условная компиляция

Работа препроцессора управляется директивами, из директив выделяются макросы
На какие группы можно разделить директивы препроцессора?
• Макроопределения
• • #define, #undef
• Директива включения файлов
• • #include
• Директивы условной компиляции
• • #if, #ifdef, #endif и др.
Остальные директивы (#pragma, #error, #line и др.) используются реже.

ВОПРОС 31

Для директивы #include
<> - Это указывает компилятору на то, что нужно искать файл заголовка в стандартных системных каталогах.
"" - Это указывает компилятору, что нужно искать файл заголовка сначала в текущем каталоге, а затем в стандартных системных каталогах.

Какие правила справедливы для всех директив препроцессора?
• Директивы всегда начинаются с символа "#".
• Любое количество пробельных символов может разделять лексемы в директиве.
• Директива заканчивается на символе '\n'.
• Директивы могут появляться в любом месте программы.

Что такое простой макрос? Как такой макрос обрабатывается препроцессором? Приведите примеры.
#define идентификатор список-замены
    #define PI 3.14
    #define EOS '\0'
    #define BEGIN {
    #define BOOL int
Для чего используются простые макросы?
Используются:
• В качестве имен для числовых, символьных и строковых констант.
• В качестве флагов для компиляции под разные платформы, версии программ (debug, production, с урезанным функционалом и т. д.)
• Для изменения поведения компилятора Feature Test Macros

Некоторые предопределенные макросы:
__FILE__: Этот макрос раскрывается в строку, содержащую имя текущего файла и путь к нему.
__LINE__: Этот макрос раскрывается в текущий номер строки в файле.
__DATE__: Этот макрос раскрывается в строку, содержащую дату компиляции программы.
__TIME__: Этот макрос раскрывается в строку, содержащую время компиляции программы.
Необязательно знать:
__STDC__: Этот макрос определен компилятором C и может использоваться для проверки соответствия компилятора стандарту языка C.
__STDC_HOSTED__: Этот макрос определен компилятором C и может использоваться для проверки, работает ли программа в окружении, поддерживающем стандартную библиотеку языка C.

ВОПРОС 32

Что такое макрос с параметрами? Как такой макрос обрабатывается препроцессором? Приведите примеры.
• #define идентификатор(x1, x2, ..., xn) список-замены
• • Не должно быть пробела между именем макроса и (.
• • Список параметров может быть пустым.
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define IS_EVEN(x) ((x) % 2 == 0)
Где-то в программе
i = MAX(j + k, m - n);
// i = ((j + k) > (m - n) ? (j + k) : (m - n));
if (IS_EVEN(i))
// if (((i) % 2 == 0))
      i++;
• Макросы с параметрами vs функции: преимущества и недостатки.
Преимущества макросов
• программа может работать немного быстрее;
• макросы "универсальны".
Недостатки макросов
• скомпилированный код становится больше;
n = MAX(i, MAX(j, k)));
• типы аргументов не проверяются;
• нельзя объявить указатель на макрос;
• макрос может вычислять аргументы несколько раз. ПРИМЕР: n = MAX(i++, j); (подставится i++ несколько раз)
Макросы с переменным числом параметров. Приведите примеры. (используется вспомогательный макрос __VA_ARGS__)
#ifndef NDEBUG
#define DBG_PRINT(s, ...) printf(s, __VA_ARGS__)
#else
#define DBG_PRINT(s, ...) ((void) 0)
#endif
Какими общими особенностями/свойствами обладают все макросы?
• Список-замены макроса может содержать другие макросы.
• Препроцессор заменяет только целые лексемы, не их части.
• Определение макроса остается «известным» до конца файла, в котором этот макрос объявляется.
• Макрос не может быть объявлен дважды, если эти объявление не тождественны.
• Макрос может быть «разопределен» с помощью директивы #undef.
Объясните правила использования скобок внутри макросов. Приведите примеры.
• Если список-замены содержит операции, он должен быть заключен в скобки.
• Если у макроса есть параметры, они должны быть заключены в скобки в списке-замены.
Внутри тела макроса круглые скобки используются для обеспечения правильного раскрытия макроса и избежания проблем с приоритетом операций.
Круглые скобки помогают гарантировать, что аргументы макроса будут правильно объединены с остальной частью выражения.
#define TWO_PI  2 * 3.14
f = 360.0 / TWO_PI;
// f = 360.0 / 2 * 3.14;
#define SCALE(x)  (x * 10)
j = SCALE(i + 1);
// j = (i + 1 * 10);

• Какие подходы к написанию "длинных" макросов вы знаете? Опишите их преимущества и недостатки. Приведите примеры.
// 1
#define ECHO(s)    {gets(s); puts(s);}
if (echo_flag)
      ECHO(str);
else
      gets(str);
// 2
#define ECHO(s)  (gets(s), puts(s))
ECHO(str);
#define ECHO(s) \
do              \
{               \
      gets(s);    \
      puts(s);    \
}               \
while(0)        \

ВОПРОС 33
     
Для чего используется условная компиляция? Приведите примеры.
Использование условной компиляции:
• программа, которая должна работать под несколькими операционными системами;
• программа, которая должна собираться различными компиляторами;
• начальное значение макросов;
• временное выключение кода.
      
Директива #if vs директива #ifdef.
Директива #if проверяет, что значение макроса истинно (не ноль, не пуст и определен),
Директива #ifdef проверяет, что макроса определен

В макросах условной компиляции нельзя использовать операцию sizeof так как препроцессор ничего не знает о размерах С
ВОПРОС 34

Операция #. Примеры использования.
«Операция» # конвертирует аргумент макроса в строковый литерал.
«Операция» ## объединяет две лексемы в одну.


#define MK_ID(n)    i##n
Где-то в программе
int MK_ID(1), MK_ID(2);
// int    i1, i2;

Или #define CONCAT(x, y) x##y // Соединить 2 int в один

Более содержательный пример

#define GENERAL_MAX(type)         \
type type##_max(type x, type y)   \
{                                 \
    return x > y ? x : y;         \
}

Особенности использования операций
Директива #error указывает компилятору в случае ее обнаружения остановить компиляцию.
Как правило, она используется для отладки. Общий вид директивы следующий:
#error сообщение_об_ошибке

сообщение_об_ошибке не заключается в двойные кавычки. Когда компилятор обнаруживает директиву, он выводит сообщение в следующем виде и завершает компиляцию:

Fatal: имя_файла номер_строки: Error directive: сообщение_об_ошибке

Здесь имя_файла — это имя файла, где была найдена директива #error,
номер_строки — это номер строки директивы, а сообщение_об_ошибке — это, собственно, само сообщение.

Директива #pragma (на примере once и pack).
#pragma once — не стандартная, но широко распространенная препроцессорная директива, разработанная для контроля за тем,
чтобы конкретный исходный файл при компиляции подключался строго один раз.
То есть, #pragma once применяется для тех же целей, что и include guard, но требует меньше кода и не допускает возможности коллизии имён.
#pragma pack(push, 1)
struct MyPackedStruct {
    char a;
    int b;
};
#pragma pack(pop)
в этом коде установливается выравнивание в 1 байт для структур

#endif

#ifdef OK // Функции

#endif


#define GENERAL_MAX(type)         \
type type##_max(type x, type y)   \
{                                 \
    return x > y ? x : y;         \
}

#define SQUARE(x) { \
    int result = (x) * (x); \
    printf("Result: %d\n", result); \
}

#define SQUARE_D(x) do { \
    int result = (x) * (x); \
    printf("Result: %d\n", result); \
} while(0)

#define PRINT_H { printf("Hard!\n"); }

GENERAL_MAX(int)

int main(void)
{
    int result = 5;
    if (result == 5)
        PRINT_H
    else
        printf("Результат: %d\n", result);
    return OK;
}